Key points of ARRAY:
store multiple values of the same type

When we create an array we can store primitives and non primitives:
byte[]
short[]
int[]
long[]
float[]
double[]
boolean[]
char[]

String[]
Object[]
Monkey[]
Fruit[]

DataTypes: 
primitives: 8
non primitives: unlimited such as string, scanner, objects, Fruit, Monkey type;

Limitations of Array:
Array is fixed in size
We do not have methods to manipulate with data(add, remove, replace)

Collections: a group of objects represented as a single unit.
Collections are the containers that store groups of objects.

Collections Frameworks is an Interface that consists of 3 interfaces.
List
Set
Queue

LIST INTEFACE: an interface apart of the collection framework that allows for duplicate elements and preserves the order of elements.
The classes that implement the LIST interface are:
1. ArrayList
2. LinkedList
3. Vector - synchronized


WHY DO WE NEED COLLECTIONS
to manipulate data
Arrays are limited in size and do not have methods to manipulate data with.
Arrays are a static data structure while arrayList is a dynamic data structure.

Wrapper Classes: class that converts primitive data types into object types
8 wrapper classes - wraps your primitive variable and now represented in the form of object
int = Integer
char = Character
boolean = Boolean
byte = Byte

Why do we need Wrapper classes?
to store converted primitive types inside our collections

when we convert primitives to non primitives they become objects and you can have access to many different methods
and properties

Iterator is an interface that helps iterate/traverse through collections (List, Set, Queue)
through each element inside the collection.

Iterator has 3 methods
hasNext() - > returns boolean if there is a next element in the collection

next(); -> returns the next element

remove(); -> removes the next element

List: an interface that is apart of the collection framework and allows duplicates elements and maintains the insertion order
ArrayList
LinkedList
Vector

ARRAYLIST vs LINKEDLIST

1.
Arraylist is a dynamic array 

LinkedList uses a doubly linked list, while ArrayList uses array

2.
ArrayList is the best option for retrieving elements

while LinkedList is best choice
for adding and removing elements


ArrayList vs Array

1. Array is fixed in size
ArrayList is a dynamic data structure

2. Array contains primitives and non primitives
ArrayList contains only objects - with the help of wrapper classes

To find elements:
3. length() - array
size() - arrayList

🧱 Structure of a LinkedList:
A LinkedList is made up of nodes.

Each node contains:

The data

A reference (or pointer) to the next node (and in DoublyLinkedList, also the previous node)

🔍 Why It’s Good for Adding/Removing:
✅ 1. No Shifting Required (like in Arrays):
In an ArrayList, adding/removing in the middle means shifting elements to maintain order.

e.g. Removing index 2 in an ArrayList of 100 items → 97 items get shifted!

In a LinkedList, you just:

Update a few pointers (like .next and .prev)

No need to shift any other elements

✅ 2. Constant Time Operations at Ends:
Adding/removing at the head (start) or tail (end) of a LinkedList takes:

O(1) time (just re-point a reference)

In contrast, ArrayList removals/additions at the front require shifting every single element.

✅ 3. Efficient Insertions/Deletions in Middle:
If you already have a reference to the node:

Insert/delete = just change .next and .prev

Time = O(1)

With an ArrayList, inserting in the middle = shift right

Deleting = shift left

⚠️ But Not Always Best...
Operation	ArrayList	LinkedList
Access (get)	✅ O(1)	❌ O(n)
Add at end	✅ O(1)*	✅ O(1)
Add/remove front	❌ O(n)	✅ O(1)
Add/remove mid	❌ O(n)	✅ O(n)*

* ArrayList add at end is amortized O(1), unless it resizes.
* LinkedList add/remove in middle requires O(n) to find the node, unless you already have it.

🔚 Summary
LinkedList is best for:

Adding/removing elements at start, end, or known positions.

Situations where insert/delete operations happen frequently.

But not best when:

You need to access elements by index often (use ArrayList for that — much faster).